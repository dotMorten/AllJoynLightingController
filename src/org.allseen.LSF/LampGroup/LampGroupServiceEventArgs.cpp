//-----------------------------------------------------------------------------
// <auto-generated>
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated.
//
//   For more information, see: http://go.microsoft.com/fwlink/?LinkID=623246
// </auto-generated>
//-----------------------------------------------------------------------------
#include "pch.h"

using namespace concurrency;
using namespace Microsoft::WRL;
using namespace Platform;
using namespace Windows::Foundation;
using namespace Windows::Foundation::Collections;
using namespace Windows::Devices::AllJoyn;
using namespace org::allseen::LSF::ControllerService::LampGroup;
namespace org { namespace allseen { namespace LSF { namespace ControllerService { namespace LampGroup {

// Methods
LampGroupGetAllLampGroupIDsCalledEventArgs::LampGroupGetAllLampGroupIDsCalledEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
    m_result = LampGroupGetAllLampGroupIDsResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGroupGetAllLampGroupIDsCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGroupGetAllLampGroupIDsCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGroupGetAllLampGroupIDsCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupGetAllLampGroupIDsCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupGetAllLampGroupIDsCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetAllLampGroupIDsCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGroupGetLampGroupNameCalledEventArgs::LampGroupGetLampGroupNameCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampGroupID,
    _In_ Platform::String^ interfaceMemberLanguage)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampGroupID(interfaceMemberLampGroupID),
    m_interfaceMemberLanguage(interfaceMemberLanguage)
{
    m_result = LampGroupGetLampGroupNameResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGroupGetLampGroupNameCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGroupGetLampGroupNameCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGroupGetLampGroupNameCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupGetLampGroupNameCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupGetLampGroupNameCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetLampGroupNameCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGroupSetLampGroupNameCalledEventArgs::LampGroupSetLampGroupNameCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampGroupID,
    _In_ Platform::String^ interfaceMemberLampGroupName,
    _In_ Platform::String^ interfaceMemberLanguage)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampGroupID(interfaceMemberLampGroupID),
    m_interfaceMemberLampGroupName(interfaceMemberLampGroupName),
    m_interfaceMemberLanguage(interfaceMemberLanguage)
{
    m_result = LampGroupSetLampGroupNameResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGroupSetLampGroupNameCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGroupSetLampGroupNameCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGroupSetLampGroupNameCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupSetLampGroupNameCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupSetLampGroupNameCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for SetLampGroupNameCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGroupCreateLampGroupCalledEventArgs::LampGroupCreateLampGroupCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Windows::Foundation::Collections::IVectorView<Platform::String^>^ interfaceMemberLampIDs,
    _In_ Windows::Foundation::Collections::IVectorView<Platform::String^>^ interfaceMemberLampGroupIDs,
    _In_ Platform::String^ interfaceMemberLampGroupName,
    _In_ Platform::String^ interfaceMemberLanguage)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampIDs(interfaceMemberLampIDs),
    m_interfaceMemberLampGroupIDs(interfaceMemberLampGroupIDs),
    m_interfaceMemberLampGroupName(interfaceMemberLampGroupName),
    m_interfaceMemberLanguage(interfaceMemberLanguage)
{
    m_result = LampGroupCreateLampGroupResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGroupCreateLampGroupCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGroupCreateLampGroupCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGroupCreateLampGroupCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupCreateLampGroupCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupCreateLampGroupCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for CreateLampGroupCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGroupUpdateLampGroupCalledEventArgs::LampGroupUpdateLampGroupCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampGroupID,
    _In_ Windows::Foundation::Collections::IVectorView<Platform::String^>^ interfaceMemberLampIDs,
    _In_ Windows::Foundation::Collections::IVectorView<Platform::String^>^ interfaceMemberLampGroupIDs)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampGroupID(interfaceMemberLampGroupID),
    m_interfaceMemberLampIDs(interfaceMemberLampIDs),
    m_interfaceMemberLampGroupIDs(interfaceMemberLampGroupIDs)
{
    m_result = LampGroupUpdateLampGroupResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGroupUpdateLampGroupCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGroupUpdateLampGroupCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGroupUpdateLampGroupCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupUpdateLampGroupCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupUpdateLampGroupCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for UpdateLampGroupCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGroupDeleteLampGroupCalledEventArgs::LampGroupDeleteLampGroupCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampGroupID)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampGroupID(interfaceMemberLampGroupID)
{
    m_result = LampGroupDeleteLampGroupResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGroupDeleteLampGroupCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGroupDeleteLampGroupCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGroupDeleteLampGroupCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupDeleteLampGroupCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupDeleteLampGroupCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for DeleteLampGroupCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGroupGetLampGroupCalledEventArgs::LampGroupGetLampGroupCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampGroupID)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampGroupID(interfaceMemberLampGroupID)
{
    m_result = LampGroupGetLampGroupResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGroupGetLampGroupCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGroupGetLampGroupCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGroupGetLampGroupCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupGetLampGroupCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupGetLampGroupCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetLampGroupCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGroupTransitionLampGroupStateCalledEventArgs::LampGroupTransitionLampGroupStateCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampGroupID,
    _In_ Windows::Foundation::Collections::IMapView<Platform::String^,Platform::Object^>^ interfaceMemberLampState,
    _In_ uint32 interfaceMemberTransitionPeriod)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampGroupID(interfaceMemberLampGroupID),
    m_interfaceMemberLampState(interfaceMemberLampState),
    m_interfaceMemberTransitionPeriod(interfaceMemberTransitionPeriod)
{
    m_result = LampGroupTransitionLampGroupStateResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGroupTransitionLampGroupStateCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGroupTransitionLampGroupStateCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGroupTransitionLampGroupStateCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupTransitionLampGroupStateCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupTransitionLampGroupStateCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for TransitionLampGroupStateCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGroupPulseLampGroupWithStateCalledEventArgs::LampGroupPulseLampGroupWithStateCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampGroupID,
    _In_ Windows::Foundation::Collections::IMapView<Platform::String^,Platform::Object^>^ interfaceMemberFromLampGroupState,
    _In_ Windows::Foundation::Collections::IMapView<Platform::String^,Platform::Object^>^ interfaceMemberToLampGroupState,
    _In_ uint32 interfaceMemberPeriod,
    _In_ uint32 interfaceMemberDuration,
    _In_ uint32 interfaceMemberNumPulses)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampGroupID(interfaceMemberLampGroupID),
    m_interfaceMemberFromLampGroupState(interfaceMemberFromLampGroupState),
    m_interfaceMemberToLampGroupState(interfaceMemberToLampGroupState),
    m_interfaceMemberPeriod(interfaceMemberPeriod),
    m_interfaceMemberDuration(interfaceMemberDuration),
    m_interfaceMemberNumPulses(interfaceMemberNumPulses)
{
    m_result = LampGroupPulseLampGroupWithStateResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGroupPulseLampGroupWithStateCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGroupPulseLampGroupWithStateCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGroupPulseLampGroupWithStateCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupPulseLampGroupWithStateCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupPulseLampGroupWithStateCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for PulseLampGroupWithStateCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGroupPulseLampGroupWithPresetCalledEventArgs::LampGroupPulseLampGroupWithPresetCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampGroupID,
    _In_ Platform::String^ interfaceMemberFromPresetID,
    _In_ Platform::String^ interfaceMemberToPresetID,
    _In_ uint32 interfaceMemberPeriod,
    _In_ uint32 interfaceMemberDuration,
    _In_ uint32 interfaceMemberNumPulses)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampGroupID(interfaceMemberLampGroupID),
    m_interfaceMemberFromPresetID(interfaceMemberFromPresetID),
    m_interfaceMemberToPresetID(interfaceMemberToPresetID),
    m_interfaceMemberPeriod(interfaceMemberPeriod),
    m_interfaceMemberDuration(interfaceMemberDuration),
    m_interfaceMemberNumPulses(interfaceMemberNumPulses)
{
    m_result = LampGroupPulseLampGroupWithPresetResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGroupPulseLampGroupWithPresetCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGroupPulseLampGroupWithPresetCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGroupPulseLampGroupWithPresetCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupPulseLampGroupWithPresetCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupPulseLampGroupWithPresetCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for PulseLampGroupWithPresetCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGroupTransitionLampGroupStateToPresetCalledEventArgs::LampGroupTransitionLampGroupStateToPresetCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampGroupID,
    _In_ Platform::String^ interfaceMemberPresetID,
    _In_ uint32 interfaceMemberTransitionPeriod)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampGroupID(interfaceMemberLampGroupID),
    m_interfaceMemberPresetID(interfaceMemberPresetID),
    m_interfaceMemberTransitionPeriod(interfaceMemberTransitionPeriod)
{
    m_result = LampGroupTransitionLampGroupStateToPresetResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGroupTransitionLampGroupStateToPresetCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGroupTransitionLampGroupStateToPresetCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGroupTransitionLampGroupStateToPresetCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupTransitionLampGroupStateToPresetCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupTransitionLampGroupStateToPresetCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for TransitionLampGroupStateToPresetCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGroupTransitionLampGroupStateFieldCalledEventArgs::LampGroupTransitionLampGroupStateFieldCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampGroupID,
    _In_ Platform::String^ interfaceMemberLampGroupStateFieldName,
    _In_ Platform::Object^ interfaceMemberLampGroupStateFieldValue,
    _In_ uint32 interfaceMemberTransitionPeriod)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampGroupID(interfaceMemberLampGroupID),
    m_interfaceMemberLampGroupStateFieldName(interfaceMemberLampGroupStateFieldName),
    m_interfaceMemberLampGroupStateFieldValue(interfaceMemberLampGroupStateFieldValue),
    m_interfaceMemberTransitionPeriod(interfaceMemberTransitionPeriod)
{
    m_result = LampGroupTransitionLampGroupStateFieldResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGroupTransitionLampGroupStateFieldCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGroupTransitionLampGroupStateFieldCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGroupTransitionLampGroupStateFieldCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupTransitionLampGroupStateFieldCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupTransitionLampGroupStateFieldCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for TransitionLampGroupStateFieldCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGroupResetLampGroupStateCalledEventArgs::LampGroupResetLampGroupStateCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampGroupID)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampGroupID(interfaceMemberLampGroupID)
{
    m_result = LampGroupResetLampGroupStateResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGroupResetLampGroupStateCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGroupResetLampGroupStateCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGroupResetLampGroupStateCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupResetLampGroupStateCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupResetLampGroupStateCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for ResetLampGroupStateCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGroupResetLampGroupStateFieldCalledEventArgs::LampGroupResetLampGroupStateFieldCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampGroupID,
    _In_ Platform::String^ interfaceMemberLampGroupStateFieldName)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampGroupID(interfaceMemberLampGroupID),
    m_interfaceMemberLampGroupStateFieldName(interfaceMemberLampGroupStateFieldName)
{
    m_result = LampGroupResetLampGroupStateFieldResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGroupResetLampGroupStateFieldCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGroupResetLampGroupStateFieldCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGroupResetLampGroupStateFieldCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupResetLampGroupStateFieldCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupResetLampGroupStateFieldCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for ResetLampGroupStateFieldCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

// Readable Properties
LampGroupGetVersionRequestedEventArgs::LampGroupGetVersionRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
    m_result = LampGroupGetVersionResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGroupGetVersionRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGroupGetVersionRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGroupGetVersionRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupGetVersionRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGroupGetVersionRequestedEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetVersionRequested.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

// Writable Properties
} } } } } 
