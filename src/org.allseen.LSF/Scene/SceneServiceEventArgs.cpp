//-----------------------------------------------------------------------------
// <auto-generated> 
//   This code was generated by a tool. 
// 
//   Changes to this file may cause incorrect behavior and will be lost if  
//   the code is regenerated.
//
//   Tool: AllJoynCodeGenerator.exe
//
//   This tool is located in the Windows 10 SDK and the Windows 10 AllJoyn 
//   Visual Studio Extension in the Visual Studio Gallery.  
//
//   The generated code should be packaged in a Windows 10 C++/CX Runtime  
//   Component which can be consumed in any UWP-supported language using 
//   APIs that are available in Windows.Devices.AllJoyn.
//
//   Using AllJoynCodeGenerator - Invoke the following command with a valid 
//   Introspection XML file and a writable output directory:
//     AllJoynCodeGenerator -i <INPUT XML FILE> -o <OUTPUT DIRECTORY>
// </auto-generated>
//-----------------------------------------------------------------------------
#include "pch.h"

using namespace concurrency;
using namespace Microsoft::WRL;
using namespace Platform;
using namespace Windows::Foundation;
using namespace Windows::Foundation::Collections;
using namespace Windows::Devices::AllJoyn;
using namespace org::allseen::LSF::ControllerService::Scene;
namespace org { namespace allseen { namespace LSF { namespace ControllerService { namespace Scene {

// Methods
SceneGetAllSceneIDsCalledEventArgs::SceneGetAllSceneIDsCalledEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
	m_result = SceneGetAllSceneIDsResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ SceneGetAllSceneIDsCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &SceneGetAllSceneIDsCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void SceneGetAllSceneIDsCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void SceneGetAllSceneIDsCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void SceneGetAllSceneIDsCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetAllSceneIDsCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

SceneGetSceneNameCalledEventArgs::SceneGetSceneNameCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberSceneID,
    _In_ Platform::String^ interfaceMemberLanguage)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberSceneID(interfaceMemberSceneID),
    m_interfaceMemberLanguage(interfaceMemberLanguage)
{
	m_result = SceneGetSceneNameResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ SceneGetSceneNameCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &SceneGetSceneNameCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void SceneGetSceneNameCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void SceneGetSceneNameCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void SceneGetSceneNameCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetSceneNameCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

SceneSetSceneNameCalledEventArgs::SceneSetSceneNameCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberSceneID,
    _In_ Platform::String^ interfaceMemberSceneName,
    _In_ Platform::String^ interfaceMemberLanguage)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberSceneID(interfaceMemberSceneID),
    m_interfaceMemberSceneName(interfaceMemberSceneName),
    m_interfaceMemberLanguage(interfaceMemberLanguage)
{
	m_result = SceneSetSceneNameResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ SceneSetSceneNameCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &SceneSetSceneNameCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void SceneSetSceneNameCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void SceneSetSceneNameCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void SceneSetSceneNameCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for SetSceneNameCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

SceneCreateSceneCalledEventArgs::SceneCreateSceneCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Windows::Foundation::Collections::IVectorView<SceneTransitionlampsLampGroupsToStateItem^>^ interfaceMemberTransitionlampsLampGroupsToState,
    _In_ Windows::Foundation::Collections::IVectorView<SceneTransitionlampsLampGroupsToPresetItem^>^ interfaceMemberTransitionlampsLampGroupsToPreset,
    _In_ Windows::Foundation::Collections::IVectorView<ScenePulselampsLampGroupsWithStateItem^>^ interfaceMemberPulselampsLampGroupsWithState,
    _In_ Windows::Foundation::Collections::IVectorView<ScenePulselampsLampGroupsWithPresetItem^>^ interfaceMemberPulselampsLampGroupsWithPreset,
    _In_ Platform::String^ interfaceMemberSceneName,
    _In_ Platform::String^ interfaceMemberLanguage)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberTransitionlampsLampGroupsToState(interfaceMemberTransitionlampsLampGroupsToState),
    m_interfaceMemberTransitionlampsLampGroupsToPreset(interfaceMemberTransitionlampsLampGroupsToPreset),
    m_interfaceMemberPulselampsLampGroupsWithState(interfaceMemberPulselampsLampGroupsWithState),
    m_interfaceMemberPulselampsLampGroupsWithPreset(interfaceMemberPulselampsLampGroupsWithPreset),
    m_interfaceMemberSceneName(interfaceMemberSceneName),
    m_interfaceMemberLanguage(interfaceMemberLanguage)
{
	m_result = SceneCreateSceneResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ SceneCreateSceneCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &SceneCreateSceneCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void SceneCreateSceneCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void SceneCreateSceneCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void SceneCreateSceneCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for CreateSceneCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

SceneUpdateSceneCalledEventArgs::SceneUpdateSceneCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberSceneID,
    _In_ Windows::Foundation::Collections::IVectorView<SceneTransitionlampsLampGroupsToStateItem^>^ interfaceMemberTransitionlampsLampGroupsToState,
    _In_ Windows::Foundation::Collections::IVectorView<SceneTransitionlampsLampGroupsToPresetItem^>^ interfaceMemberTransitionlampsLampGroupsToPreset,
    _In_ Windows::Foundation::Collections::IVectorView<ScenePulselampsLampGroupsWithStateItem^>^ interfaceMemberPulselampsLampGroupsWithState,
    _In_ Windows::Foundation::Collections::IVectorView<ScenePulselampsLampGroupsWithPresetItem^>^ interfaceMemberPulselampsLampGroupsWithPreset)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberSceneID(interfaceMemberSceneID),
    m_interfaceMemberTransitionlampsLampGroupsToState(interfaceMemberTransitionlampsLampGroupsToState),
    m_interfaceMemberTransitionlampsLampGroupsToPreset(interfaceMemberTransitionlampsLampGroupsToPreset),
    m_interfaceMemberPulselampsLampGroupsWithState(interfaceMemberPulselampsLampGroupsWithState),
    m_interfaceMemberPulselampsLampGroupsWithPreset(interfaceMemberPulselampsLampGroupsWithPreset)
{
	m_result = SceneUpdateSceneResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ SceneUpdateSceneCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &SceneUpdateSceneCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void SceneUpdateSceneCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void SceneUpdateSceneCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void SceneUpdateSceneCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for UpdateSceneCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

SceneDeleteSceneCalledEventArgs::SceneDeleteSceneCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberSceneID)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberSceneID(interfaceMemberSceneID)
{
	m_result = SceneDeleteSceneResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ SceneDeleteSceneCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &SceneDeleteSceneCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void SceneDeleteSceneCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void SceneDeleteSceneCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void SceneDeleteSceneCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for DeleteSceneCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

SceneGetSceneCalledEventArgs::SceneGetSceneCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberSceneID)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberSceneID(interfaceMemberSceneID)
{
	m_result = SceneGetSceneResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ SceneGetSceneCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &SceneGetSceneCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void SceneGetSceneCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void SceneGetSceneCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void SceneGetSceneCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetSceneCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

SceneApplySceneCalledEventArgs::SceneApplySceneCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberSceneID)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberSceneID(interfaceMemberSceneID)
{
	m_result = SceneApplySceneResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ SceneApplySceneCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &SceneApplySceneCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void SceneApplySceneCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void SceneApplySceneCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void SceneApplySceneCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for ApplySceneCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

// Readable Properties
SceneGetVersionRequestedEventArgs::SceneGetVersionRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
	m_result = SceneGetVersionResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ SceneGetVersionRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &SceneGetVersionRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void SceneGetVersionRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void SceneGetVersionRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void SceneGetVersionRequestedEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetVersionRequested.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

// Writable Properties
} } } } } 
