//-----------------------------------------------------------------------------
// <auto-generated>
//   This code was generated by a tool.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated.
//
//   For more information, see: http://go.microsoft.com/fwlink/?LinkID=623246
// </auto-generated>
//-----------------------------------------------------------------------------
#include "pch.h"

using namespace concurrency;
using namespace Microsoft::WRL;
using namespace Platform;
using namespace Windows::Foundation;
using namespace Windows::Foundation::Collections;
using namespace Windows::Devices::AllJoyn;
using namespace org::allseen::LSF::ControllerService::Lamp;
namespace org { namespace allseen { namespace LSF { namespace ControllerService { namespace Lamp {

// Methods
LampGetAllLampIDsCalledEventArgs::LampGetAllLampIDsCalledEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
    m_result = LampGetAllLampIDsResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGetAllLampIDsCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGetAllLampIDsCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGetAllLampIDsCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetAllLampIDsCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetAllLampIDsCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetAllLampIDsCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGetLampSupportedLanguagesCalledEventArgs::LampGetLampSupportedLanguagesCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID)
{
    m_result = LampGetLampSupportedLanguagesResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGetLampSupportedLanguagesCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGetLampSupportedLanguagesCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGetLampSupportedLanguagesCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampSupportedLanguagesCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampSupportedLanguagesCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetLampSupportedLanguagesCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGetLampManufacturerCalledEventArgs::LampGetLampManufacturerCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID,
    _In_ Platform::String^ interfaceMemberLanguage)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID),
    m_interfaceMemberLanguage(interfaceMemberLanguage)
{
    m_result = LampGetLampManufacturerResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGetLampManufacturerCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGetLampManufacturerCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGetLampManufacturerCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampManufacturerCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampManufacturerCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetLampManufacturerCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGetLampNameCalledEventArgs::LampGetLampNameCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID,
    _In_ Platform::String^ interfaceMemberLanguage)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID),
    m_interfaceMemberLanguage(interfaceMemberLanguage)
{
    m_result = LampGetLampNameResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGetLampNameCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGetLampNameCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGetLampNameCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampNameCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampNameCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetLampNameCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampSetLampNameCalledEventArgs::LampSetLampNameCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID,
    _In_ Platform::String^ interfaceMemberLampName,
    _In_ Platform::String^ interfaceMemberLanguage)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID),
    m_interfaceMemberLampName(interfaceMemberLampName),
    m_interfaceMemberLanguage(interfaceMemberLanguage)
{
    m_result = LampSetLampNameResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampSetLampNameCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampSetLampNameCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampSetLampNameCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampSetLampNameCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampSetLampNameCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for SetLampNameCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGetLampDetailsCalledEventArgs::LampGetLampDetailsCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID)
{
    m_result = LampGetLampDetailsResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGetLampDetailsCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGetLampDetailsCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGetLampDetailsCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampDetailsCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampDetailsCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetLampDetailsCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGetLampParametersCalledEventArgs::LampGetLampParametersCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID)
{
    m_result = LampGetLampParametersResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGetLampParametersCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGetLampParametersCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGetLampParametersCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampParametersCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampParametersCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetLampParametersCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGetLampParametersFieldCalledEventArgs::LampGetLampParametersFieldCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID,
    _In_ Platform::String^ interfaceMemberLampParameterFieldName)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID),
    m_interfaceMemberLampParameterFieldName(interfaceMemberLampParameterFieldName)
{
    m_result = LampGetLampParametersFieldResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGetLampParametersFieldCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGetLampParametersFieldCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGetLampParametersFieldCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampParametersFieldCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampParametersFieldCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetLampParametersFieldCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGetLampStateCalledEventArgs::LampGetLampStateCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID)
{
    m_result = LampGetLampStateResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGetLampStateCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGetLampStateCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGetLampStateCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampStateCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampStateCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetLampStateCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGetLampStateFieldCalledEventArgs::LampGetLampStateFieldCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID,
    _In_ Platform::String^ interfaceMemberLampStateFieldName)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID),
    m_interfaceMemberLampStateFieldName(interfaceMemberLampStateFieldName)
{
    m_result = LampGetLampStateFieldResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGetLampStateFieldCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGetLampStateFieldCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGetLampStateFieldCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampStateFieldCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampStateFieldCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetLampStateFieldCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampTransitionLampStateCalledEventArgs::LampTransitionLampStateCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID,
    _In_ Windows::Foundation::Collections::IMapView<Platform::String^,Platform::Object^>^ interfaceMemberLampState,
    _In_ uint32 interfaceMemberTransitionPeriod)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID),
    m_interfaceMemberLampState(interfaceMemberLampState),
    m_interfaceMemberTransitionPeriod(interfaceMemberTransitionPeriod)
{
    m_result = LampTransitionLampStateResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampTransitionLampStateCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampTransitionLampStateCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampTransitionLampStateCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampTransitionLampStateCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampTransitionLampStateCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for TransitionLampStateCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampPulseLampWithStateCalledEventArgs::LampPulseLampWithStateCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID,
    _In_ Windows::Foundation::Collections::IMapView<Platform::String^,Platform::Object^>^ interfaceMemberFromLampState,
    _In_ Windows::Foundation::Collections::IMapView<Platform::String^,Platform::Object^>^ interfaceMemberToLampState,
    _In_ uint32 interfaceMemberPeriod,
    _In_ uint32 interfaceMemberDuration,
    _In_ uint32 interfaceMemberNumPulses)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID),
    m_interfaceMemberFromLampState(interfaceMemberFromLampState),
    m_interfaceMemberToLampState(interfaceMemberToLampState),
    m_interfaceMemberPeriod(interfaceMemberPeriod),
    m_interfaceMemberDuration(interfaceMemberDuration),
    m_interfaceMemberNumPulses(interfaceMemberNumPulses)
{
    m_result = LampPulseLampWithStateResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampPulseLampWithStateCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampPulseLampWithStateCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampPulseLampWithStateCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampPulseLampWithStateCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampPulseLampWithStateCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for PulseLampWithStateCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampPulseLampWithPresetCalledEventArgs::LampPulseLampWithPresetCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID,
    _In_ Platform::String^ interfaceMemberFromPresetID,
    _In_ Platform::String^ interfaceMemberToPresetID,
    _In_ uint32 interfaceMemberPeriod,
    _In_ uint32 interfaceMemberDuration,
    _In_ uint32 interfaceMemberNumPulses)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID),
    m_interfaceMemberFromPresetID(interfaceMemberFromPresetID),
    m_interfaceMemberToPresetID(interfaceMemberToPresetID),
    m_interfaceMemberPeriod(interfaceMemberPeriod),
    m_interfaceMemberDuration(interfaceMemberDuration),
    m_interfaceMemberNumPulses(interfaceMemberNumPulses)
{
    m_result = LampPulseLampWithPresetResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampPulseLampWithPresetCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampPulseLampWithPresetCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampPulseLampWithPresetCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampPulseLampWithPresetCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampPulseLampWithPresetCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for PulseLampWithPresetCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampTransitionLampStateToPresetCalledEventArgs::LampTransitionLampStateToPresetCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID,
    _In_ Platform::String^ interfaceMemberPresetID,
    _In_ uint32 interfaceMemberTransitionPeriod)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID),
    m_interfaceMemberPresetID(interfaceMemberPresetID),
    m_interfaceMemberTransitionPeriod(interfaceMemberTransitionPeriod)
{
    m_result = LampTransitionLampStateToPresetResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampTransitionLampStateToPresetCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampTransitionLampStateToPresetCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampTransitionLampStateToPresetCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampTransitionLampStateToPresetCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampTransitionLampStateToPresetCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for TransitionLampStateToPresetCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampTransitionLampStateFieldCalledEventArgs::LampTransitionLampStateFieldCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID,
    _In_ Platform::String^ interfaceMemberLampStateFieldName,
    _In_ Platform::Object^ interfaceMemberLampStateFieldValue,
    _In_ uint32 interfaceMemberTransitionPeriod)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID),
    m_interfaceMemberLampStateFieldName(interfaceMemberLampStateFieldName),
    m_interfaceMemberLampStateFieldValue(interfaceMemberLampStateFieldValue),
    m_interfaceMemberTransitionPeriod(interfaceMemberTransitionPeriod)
{
    m_result = LampTransitionLampStateFieldResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampTransitionLampStateFieldCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampTransitionLampStateFieldCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampTransitionLampStateFieldCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampTransitionLampStateFieldCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampTransitionLampStateFieldCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for TransitionLampStateFieldCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampResetLampStateCalledEventArgs::LampResetLampStateCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID)
{
    m_result = LampResetLampStateResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampResetLampStateCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampResetLampStateCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampResetLampStateCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampResetLampStateCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampResetLampStateCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for ResetLampStateCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampResetLampStateFieldCalledEventArgs::LampResetLampStateFieldCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID,
    _In_ Platform::String^ interfaceMemberLampStateFieldName)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID),
    m_interfaceMemberLampStateFieldName(interfaceMemberLampStateFieldName)
{
    m_result = LampResetLampStateFieldResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampResetLampStateFieldCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampResetLampStateFieldCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampResetLampStateFieldCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampResetLampStateFieldCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampResetLampStateFieldCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for ResetLampStateFieldCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGetLampFaultsCalledEventArgs::LampGetLampFaultsCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID)
{
    m_result = LampGetLampFaultsResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGetLampFaultsCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGetLampFaultsCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGetLampFaultsCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampFaultsCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampFaultsCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetLampFaultsCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampClearLampFaultCalledEventArgs::LampClearLampFaultCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID,
    _In_ uint32 interfaceMemberLampFault)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID),
    m_interfaceMemberLampFault(interfaceMemberLampFault)
{
    m_result = LampClearLampFaultResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampClearLampFaultCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampClearLampFaultCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampClearLampFaultCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampClearLampFaultCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampClearLampFaultCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for ClearLampFaultCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

LampGetLampServiceVersionCalledEventArgs::LampGetLampServiceVersionCalledEventArgs(
    _In_ AllJoynMessageInfo^ info,
    _In_ Platform::String^ interfaceMemberLampID)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info),
    m_interfaceMemberLampID(interfaceMemberLampID)
{
    m_result = LampGetLampServiceVersionResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGetLampServiceVersionCalledEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGetLampServiceVersionCalledEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGetLampServiceVersionCalledEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampServiceVersionCalledEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetLampServiceVersionCalledEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetLampServiceVersionCalled.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

// Readable Properties
LampGetVersionRequestedEventArgs::LampGetVersionRequestedEventArgs(
    _In_ AllJoynMessageInfo^ info)
    : m_raised(false),
    m_completionsRequired(0),
    m_messageInfo(info)
{
    m_result = LampGetVersionResult::CreateFailureResult(ER_NOT_IMPLEMENTED);
}

Deferral^ LampGetVersionRequestedEventArgs::GetDeferral()
{
    std::lock_guard<std::mutex> lockGuard(m_lock);
    if (m_raised)
    {
        // Cannot ask for a deferral after the event handler has returned.
        throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
    }

    m_completionsRequired++;
    auto handler = ref new DeferralCompletedHandler(this, &LampGetVersionRequestedEventArgs::Complete);
    return ref new Deferral(handler);
}

void LampGetVersionRequestedEventArgs::InvokeAllFinished()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        m_raised = true;
        invokeNeeded = (m_completionsRequired == 0);
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetVersionRequestedEventArgs::Complete()
{
    bool invokeNeeded;

    // We need to hold a lock while modifying private state, but release it before invoking a completion handler.
    {
        std::lock_guard<std::mutex> lockGuard(m_lock);
        if (m_completionsRequired == 0)
        {
            // This should never happen since Complete() should only be called by Windows.Foundation.Deferral
            // which will only invoke our completion handler once.
            throw Exception::CreateException(E_ILLEGAL_METHOD_CALL);
        }
        m_completionsRequired--;
        invokeNeeded = (m_raised && (m_completionsRequired == 0));
    }

    if (invokeNeeded)
    {
        InvokeCompleteHandler();
    }
}

void LampGetVersionRequestedEventArgs::InvokeCompleteHandler()
{
    if (m_result->Status == ER_NOT_IMPLEMENTED)
    {
        throw Exception::CreateException(E_NOTIMPL, "No handlers are registered for GetVersionRequested.");
    }
    else
    {
        m_tce.set(m_result);
    }
}

// Writable Properties
} } } } } 
